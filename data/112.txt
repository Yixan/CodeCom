                 validation_labels):lf.training_labels = training_labelslf.validation_data = validation_datalf.validation_labels = validation_labels setParams(self, batch_size, nodeList):lf.batch_size = batch_sizef build(self, time_distributed):eras.layers import Dense, Masking, LSTM, TimeDistributeddel = Sequential()del.add(Masking(mask_value = 0.0,batch_input_shape=(self.batch_size,self.training_data.shape[1],self.training_data.shape[2])))len(self.nodeList) > 1: nodes in self.nodeList[:-1]:model.add(LSTM(nodes,ctivation='tanh', return_sequences=True))model.add(LSTM(self.nodeList[-1],activation='tanh'))else:f time_distributed:odel.add(LSTM(self.nodeList[0], activation='tanh',return_sequences=True))else:odel.add(LSTM(self.nodeList[0], activation='tanh',return_sequences=False))f time_distributed:odel.add(TimeDistributed(Dense(10, activation='sigmoid')))else:odel.add(Dense(1, activation='sigmoid'))return(model)lass CNN():validation_labels):lf.training_labels = training_labelslf.validation_data = validation_datalf.validation_labels = validation_labelssetParams(self, filters, kernel_size, batch_size):lf.filters = filterslf.kernel_size = kernel_sizelf.batch_size = batch_sizeef build(self):m keras.models import Sequentialm keras.layers.convolutional import Conv2Dm keras.layers.convolutional import MaxPooling2Dkeras.layers import Dense, Dropout, Flattendel = Sequential()del.add(Conv2D(self.filters[0], kernel_size=self.kernel_size[0], activation=self.activation,
